function [] = exportDataCubeToPottersWheel(data, Parameters)
% exportDataCubeToPottersWheel exports data to a MIDAS text file
%
% exportDataCubeToPottersWheel(data, Parameters)
%--------------------------------------------------------------------------
% INPUTS:
% data          = data cube
% Parameters
%   .OutputFile = required output file name
%   .Labels     = required labels structure
%   .Delimiter('\t') = optional column delimiter, e.g. "," or "\t"
%
% OUTPUTS: None
%
% Note: Assumes canonical form
%--------------------------------------------------------------------------
% EXAMPLE:
% exportDataCubeToPottersWheel(Compendium.data(1).Value, ...
%    struct('OutputFile', 'MID-1111-data.csv', ...
%           'Labels',     Compendium.data(1).Labels));
%
%--------------------------------------------------------------------------
% TODO:
%
% - Handle combination treatments (e.g. multiple cytokines)
% - Handle (multiple) concentrations (e.g. TNF=1, TNF=2)
% - Handle non-canonical inputs
% - Better handle missing data


%--------------------------------------------------------------------------
% Copyright 2007 President and Fellow of Harvard College
%
%
%  This file is part of SBPipeline.
%
%    SBPipeline is free software; you can redistribute it and/or modify
%    it under the terms of the GNU Lesser General Public License as published by
%    the Free Software Foundation; either version 3 of the License, or
%    (at your option) any later version.
%
%    SBPipeline is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU Lesser General Public License for more details.
% 
%    You should have received a copy of the GNU Lesser General Public License
%    along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%    Contact: Julio Saez-Rodriguez       Arthur Goldsipe
%    SBPipeline.harvard.edu%

%% Check parameters
DefaultParameters = struct(...
    'OutputFile', [], ...
    'Labels', [], ...
    'Delimiter', '\t');
Parameters = setParameters(DefaultParameters, Parameters);
if isempty(Parameters.OutputFile) || ~ischar(Parameters.OutputFile)
    error('Required parameter OutputFile was not specified.');
end
labels = Parameters.Labels;
if isempty(labels) || ~isstruct(labels) || ~all(isfield(labels, {'Name', 'Value'}))
    error('Required parameter Labels was not correctly specified.');
end

dlm = sprintf(Parameters.Delimiter);
nl = sprintf('\n');
%% Identify dimensions (assumes canonical)
treatmentDims = [1 3 4];
timeDim = 2;
signalDim = 5;
sz = size(data);
%% open file
fid = fopen(Parameters.OutputFile, 'w');
try
%% Print free-text header
fprintf(fid, '# Data file automatically generated by SBPipeline function %s\n#\n', mfilename);
%% Reshape cube
    [newData, newLabels] = collapseDataCube(data, ...
        struct('Dims', treatmentDims, 'Labels', labels));
%% Identify treatments, dropping null treatments
    nTreatment = size(newData, 1);
    idx = cell(1,numel(treatmentDims));
    % drivingFucntions is a 2D array
    % each row is a different treatment
    % each column specifies the level of that treatment dimension
    drivingFunctions = zeros([nTreatment numel(treatmentDims)]);
    for i=nTreatment:-1:1
        [idx{:}] = ind2sub(sz(treatmentDims), i);
        if all(isnan(newData(i,:)))
            % Delete a treatment with all missing data
            newData(i,:,:) = [];
            drivingFunctions(i,:) = [];
        else
            % generate driving function for this treatment
            drivingFunctions(i,:) = [idx{:}];
        end
    end
    nTreatment = size(newData,1);
%% Print Driving functions
    fprintf(fid, '# Driving functions:\n');
    iSpecies = 0;
    for i=1:numel(treatmentDims)
        trNames = labels(treatmentDims(i)).Value;
        if ischar(trNames)
            trNames = {trNames};
        elseif isnumeric(trNames)
            error('Treatment names (dimension %d) must be strings', treatmentDims(i));
        end
        for j=1:numel(trNames)
            iSpecies = iSpecies + 1;
            fprintf(fid, '# MCode drivingFunctions(%d).name = ''%s'';\n', ...
                iSpecies, trNames{j});
            for k=1:nTreatment
                fprintf(fid, '# MCode drivingFunctions(%d).stimuli(%d)=', ...
                    iSpecies, k);
                fprintf(fid, 'pwGetDrivingFunction(''steps'',');
                if drivingFunctions(k,i) == j
                    fprintf(fid, '[-1 0], [0 1]');
                else
                    fprintf(fid, '[-1],   [0]  ');
                end
                fprintf(fid, ');\n');
            end
        end
    end
%% Print column titles
%     trHash = java.util.HashMap;
%     trCount = 0;
    fprintf(fid, ['# parCol-Stimulus' dlm 'xCol-Time']);
    % Handle special case of single string label.value
    if sz(signalDim) == 1 && ischar(labels(signalDim).Value)
        labels(signalDim).Value = {labels(signalDim).Value};
    end
    fprintf(fid,[dlm '%s'], labels(signalDim).Value{:});
    fprintf(fid, '\n');
%% Print each row of data
    idx = cell(1,numel(treatmentDims));
    for i=1:size(newData,1)
        for k=1:sz(timeDim)
            % Don't print out this time if there are no measurements
            if all(isnan(newData(i,k,:)))
                continue
            end
            fprintf(fid, '%d', i); % parCol
            fprintf(fid, [dlm '%g'], labels(timeDim).Value(k)); % xCol-Time
            fprintf(fid, [dlm '%g'], newData(i,k,:)); % variables
            fprintf(fid, '\n');
        end
    end
catch
%% Close file
    fclose(fid);
    rethrow(lasterror);
end
fclose(fid);